<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFMPEG Batch/Shell Script Generator</title>
    <style>
/* Global & Body */
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
    margin: 0; /* Remove default margin */
    padding: 20px; /* Add padding to body instead of margin for full-width background */
    line-height: 1.6;
    background-color: #f0f2f5;
    color: #333333; /* Softer dark gray for body text */
}

.container {
    max-width: 900px;
    margin: auto;
    background: #ffffff;
    padding: 20px 30px; /* Increased horizontal padding */
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}

/* Headings */
h1 {
    text-align: center;
    color: #1D1D1F; /* Specific dark color for main heading */
    font-weight: 600;
    margin-bottom: 30px; /* More space below main title */
}

h2 { /* For main section titles like "Input Parameters", "Generated Scripts" */
    font-weight: 500;
    color: #333333; /* Softer dark gray */
    border-bottom: 1px solid #e5e5ea;
    padding-bottom: 10px; 
    margin-top: 30px;
    margin-bottom: 25px; 
}

.script-output-area h3 { /* For "Windows Batch Script (.bat)" etc. */
    font-weight: 500;
    color: #333333; /* Softer dark gray */
    margin-top: 0;
    margin-bottom: 15px; 
    font-size: 1.1em; 
}

.mac-instructions h4 { /* For "Using the Shell Script on macOS" */
    font-weight: 500;
    color: #333333; /* Consistent softer dark gray */
    margin-top: 5px; 
    margin-bottom: 10px;
}

/* General Paragraph and Label Text */
p, #paramsForm label {
    color: #555555; /* Mid-gray for readability */
}

/* Form Elements */
#paramsForm div {
    margin-bottom: 20px; 
}

#paramsForm label {
    display: block;
    margin-bottom: 6px; 
    font-weight: 500; /* Already set, but confirming */
}

#paramsForm input[type="text"] {
    width: calc(100% - 26px); 
    padding: 12px;
    border: 1px solid #d1d1d6;
    border-radius: 8px;
    background-color: #f0f2f5; /* iOS-like input background */
    transition: border-color 0.2s, box-shadow 0.2s;
    box-sizing: border-box;
}

#paramsForm input[type="text"]:focus {
    border-color: #007aff;
    box-shadow: 0 0 0 3px rgba(0,122,255,0.25); 
    outline: none;
    background-color: #ffffff; 
}

#paramsForm small {
    font-size: 0.85em; 
    color: #6D6D6D; /* Slightly adjusted mid-gray for small text */
    display: block;
    margin-top: 5px; 
}

/* Buttons */
button {
    border-radius: 8px;
    padding: 12px 18px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s; /* Added transform */
    border: none;
    text-align: center;
}
button:active {
    transform: scale(0.98); /* Slight press effect */
}


#generateBtn {
    background-color: #007aff;
    color: white;
    display: block; /* Make it block to center it */
    margin: 25px auto 20px auto; /* Center button and add vertical margin */
    min-width: 200px; /* Ensure a decent size */
}

#generateBtn:hover {
    background-color: #005ecb;
}

button.copy-btn {
    background-color: #e5e5ea;
    color: #007aff;
    border: 1px solid #d1d1d6; /* Subtle border */
    padding: 8px 12px; /* Adjusted padding */
    font-size: 0.9em;
    margin-top: 8px; /* Space from textarea */
    display: block; /* Take full width of its container if needed, or inline-block */
    width: 100%; /* Make copy buttons take full width of their parent .script-output-area */
    box-sizing: border-box;
}

button.copy-btn:hover {
    background-color: #dcdce0; /* Slightly darker hover */
}

/* Text Areas */
textarea {
    width: calc(100% - 26px); /* Adjusted for 12px padding + 1px border on each side */
    font-family: "SF Mono", "Menlo", "Consolas", "Courier New", monospace;
    background-color: #f0f2f5; /* Consistent with input fields */
    border: 1px solid #d1d1d6;
    border-radius: 8px;
    padding: 12px;
    box-sizing: border-box;
    margin-bottom: 8px; /* Space before copy button */
    line-height: 1.5; /* Improved readability for code */
}

/* Script Output Sections */
.script-output-container {
    display: flex;
    justify-content: space-between;
    gap: 25px; /* Increased gap */
    margin-top: 25px;
}

.script-output-area {
    flex: 1;
    min-width: 0; /* Allow flex items to shrink below their content size if needed */
    background-color: #ffffff; /* White background for each area */
    padding: 20px; /* Increased padding */
    border-radius: 10px; /* Consistent with container */
    box-shadow: 0 2px 6px rgba(0,0,0,0.06); /* Softer shadow */
}

/* Collapsible Section (.mac-instructions) */
.mac-instructions {
    margin-top: 30px; /* Space above details section */
    padding: 15px;
    background-color: #f9f9f9; /* Slight background to differentiate */
    border-radius: 8px;
    border: 1px solid #e5e5ea;
}
.mac-instructions summary {
    font-weight: 500;
    color: #007aff;
    cursor: pointer;
    padding: 8px 0;
    list-style-position: inside; /* Better alignment for marker if it was default */
}
.mac-instructions summary:hover {
    text-decoration: underline;
}
.mac-instructions div { /* Content wrapper inside details */
    padding: 10px 0 10px 25px; /* Increased left padding for indentation */
    border-left: 2px solid #007aff; /* Changed border color to accent */
    margin-left: 8px; /* Adjusted margin */
    margin-top: 8px;
}
.mac-instructions ol {
    padding-left: 20px; /* Standard padding for ol */
}
.mac-instructions ol li {
    margin-bottom: 10px; /* Increased spacing */
    line-height: 1.5;
}
.mac-instructions code { /* Style for <code> tags */
    background-color: #e5e5ea;
    padding: 2px 5px;
    border-radius: 4px;
    font-family: "SF Mono", "Menlo", "Consolas", "Courier New", monospace;
}


/* Links */
a {
    color: #007aff;
    text-decoration: none;
}
a:hover {
    text-decoration: underline;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .container {
        padding: 15px 20px; /* Reduced padding for smaller screens */
    }
    .script-output-container {
        flex-direction: column;
        gap: 20px; /* Gap for stacked items */
    }
    #paramsForm input[type="text"], textarea, button.copy-btn {
        width: 100%; /* Full width for these elements */
    }
    h1 {
        font-size: 1.8em; /* Adjust main title size */
    }
    h2 {
        font-size: 1.3em; /* Adjust section title size */
    }
    .script-output-area h3 {
        font-size: 1.1em;
    }
}
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>FFMPEG Batch/Shell Script Generator</h1>
    </header>

    <section id="introduction">
        <p>This tool helps you generate simple FFMPEG commands wrapped in batch (for Windows) or shell (for Linux/macOS) scripts. Fill in the parameters below to customize the FFMPEG command for your video conversion needs.</p>
        <p><strong>Important:</strong> You must have FFMPEG installed and accessible in your system's PATH for these scripts to work. Download FFMPEG from <a href="https://ffmpeg.org/download.html" target="_blank">ffmpeg.org</a>.</p>
    </section>

    <section id="input-parameters">
        <h2>Input Parameters</h2>
        <form id="paramsForm">
            <div>
                <label for="resolution">Resolution (e.g., 1280x720):</label>
                <input type="text" id="resolution" placeholder="Leave blank for original">
                <small>Optional. Example: 1920x1080. If left blank, FFMPEG will use the original resolution.</small>
            </div>
            <div>
                <label for="videoCodec">Video Codec:</label>
                <input type="text" id="videoCodec" value="libx264">
                <small>Example: libx264 (for H.264), libvpx-vp9 (for VP9). Default is libx264.</small>
            </div>
            <div>
                <label for="audioCodec">Audio Codec:</label>
                <input type="text" id="audioCodec" value="aac">
                <small>Example: aac, libopus. Default is aac.</small>
            </div>
            <div>
                <label for="videoBitrate">Video Bitrate (e.g., 1M, 2000k):</label>
                <input type="text" id="videoBitrate" placeholder="Leave blank for default">
                <small>Optional. Example: 1M (for 1 Mbps), 500k (for 500 Kbps). If left blank, FFMPEG uses its defaults.</small>
            </div>
        </form>
    </section>

    <section id="actions">
        <button type="button" id="generateBtn">‚öôÔ∏è Generate Scripts</button>
    </section>

    <section id="output-scripts">
        <h2>Generated Scripts</h2>
        <div class="script-output-container">
            <div class="script-output-area" id="windows-script-area_"> <!-- id was windows-script-area -->
                <h3>Windows Batch Script (.bat)</h3>
                <p>Copy the text below and save it as a `.bat` file (e.g., `convert_video.bat`). Remember to replace placeholder file names with your actual file names before running.</p>
                <textarea id="windowsScript" readonly rows="10" placeholder="Windows batch script will appear here..."></textarea>
                <button type="button" id="copyWindowsBtn" class="copy-btn">üìÑ Copy Windows Script</button>
            </div>

            <div class="script-output-area" id="linux-script-area_"> <!-- id was linux-script-area -->
                <h3>Linux/macOS Shell Script (.sh)</h3>
                <p>Copy the text below and save it as a `.sh` file (e.g., `convert_video.sh`). Make it executable with `chmod +x convert_video.sh`. Remember to replace placeholder file names.</p>
                <textarea id="linuxScript" readonly rows="10" placeholder="Linux shell script will appear here..."></textarea>
                <button type="button" id="copyLinuxBtn" class="copy-btn">üìÑ Copy Linux Script</button>
            </div>
        </div>
    </section>

    <details class="mac-instructions">
        <summary>‚ÑπÔ∏è Instructions for macOS Users</summary>
        <div>
            <h4>Using the Shell Script on macOS</h4>
            <p>The Linux Shell Script (.sh file) generated above is also suitable for macOS users. Here‚Äôs how to use it:</p>
            <ol>
                <li>Open <strong>Terminal</strong>. You can find it in <code>/Applications/Utilities/</code> or search for it using Spotlight (Cmd + Space).</li>
                <li>Navigate to the directory where you saved your <code>.sh</code> script file using the <code>cd</code> command (e.g., <code>cd ~/Downloads</code>).</li>
                <li>Make the script executable by typing <code>chmod +x YOUR_SCRIPT_NAME.sh</code> (replace <code>YOUR_SCRIPT_NAME.sh</code> with the actual name of your file) and pressing Enter.</li>
                <li>Run the script by typing <code>./YOUR_SCRIPT_NAME.sh</code> and pressing Enter.</li>
                <li><strong>FFMPEG Installation (if needed):</strong> If you don't have FFMPEG installed, a common way to install it on macOS is using Homebrew. First, install Homebrew from <a href="https://brew.sh/" target="_blank" rel="noopener noreferrer">brew.sh</a> (if you don't have it), then run: <code>brew install ffmpeg</code> in Terminal.</li>
            </ol>
        </div>
    </details>

</div> <!-- End of .container -->
    <script>
'use strict';

document.addEventListener('DOMContentLoaded', () => {
    // DOM Element Selection
    // const inputFileEl = document.getElementById('inputFilePlaceholder'); // Removed
    // const outputFileEl = document.getElementById('outputFilePlaceholder'); // Removed
    const resolutionEl = document.getElementById('resolution');
    const videoCodecEl = document.getElementById('videoCodec');
    const audioCodecEl = document.getElementById('audioCodec');
    const videoBitrateEl = document.getElementById('videoBitrate'); 
    const generateBtn = document.getElementById('generateBtn');
    const windowsScriptArea = document.getElementById('windowsScript'); 
    const linuxScriptArea = document.getElementById('linuxScript');   
    const copyWindowsBtn = document.getElementById('copyWindowsBtn');
    const copyLinuxBtn = document.getElementById('copyLinuxBtn');

    // quoteFilename function is removed as placeholders are fixed strings.
    
    // generateFfmpegCommand Function
    function generateFfmpegCommand(params) {
        const commandParts = ['ffmpeg', '-y']; // Start with ffmpeg and -y for overwrite

        // Use fixed placeholders for input and output files
        commandParts.push('-i', '"$INPUT_FILE"');

        if (params.resolution) {
            commandParts.push('-s', params.resolution);
        }
        if (params.videoCodec) {
            commandParts.push('-c:v', params.videoCodec);
        }
        // Provide default video codec if none is specified
        else {
            commandParts.push('-c:v', 'libx264'); 
        }

        if (params.audioCodec) {
            commandParts.push('-c:a', params.audioCodec);
        }
        // Provide default audio codec if none is specified
        else {
            commandParts.push('-c:a', 'aac');
        }

        if (params.bitrate) {
            commandParts.push('-b:v', params.bitrate);
        }

        // Output file - use fixed placeholder
        commandParts.push('"$OUTPUT_FILE_REENCODED"');

        return commandParts.join(' ');
    }

    // generateWindowsScript Function
    function generateWindowsScript(ffmpegCommandWithPlaceholders, params) {
        // Using template literals for multi-line string.
        // Note: The batch script uses !VAR! for delayed expansion, and %%A for loop variables.
        // The placeholders "$INPUT_FILE$" and "$OUTPUT_FILE_REENCODED$" (with quotes) are literal strings
        // that will be present in ffmpegCommandWithPlaceholders and then replaced inside the batch script.
        const script = `@echo off
REM This script processes files dragged onto it.
REM It re-encodes them using FFMPEG with the specified parameters,
REM adding "_reencoded" to the original filename.

SETLOCAL ENABLEDELAYEDEXPANSION

REM Loop through all files dragged onto the script
FOR %%A IN (%*) DO (
    echo Processing file: "%%~A"

    REM Get filename components
    SET "INPUT_FILE_PATH=%%~A"
    SET "BASENAME=%%~nA"
    SET "EXTENSION=%%~xA"

    REM Construct output filename
    SET "OUTPUT_FILENAME=!BASENAME!_reencoded!EXTENSION!"

    echo Output will be: "!OUTPUT_FILENAME!"

    REM Prepare the FFMPEG command for the current file
    SET "ACTUAL_FFMPEG_COMMAND=${ffmpegCommandWithPlaceholders}"
    
    REM Replace the "$INPUT_FILE" placeholder.
    SET "CMD_TEMP=!ACTUAL_FFMPEG_COMMAND:"$INPUT_FILE"="%%~A"!"
    REM Replace the "$OUTPUT_FILE_REENCODED" placeholder.
    SET "FINAL_CMD=!CMD_TEMP:"$OUTPUT_FILE_REENCODED"="!OUTPUT_FILENAME!"!"
    
    REM Execute FFMPEG
    echo Running: !FINAL_CMD!
    !FINAL_CMD!

    echo.
)

echo All files processed.
pause
`;
        return script;
    }

    // generateLinuxScript Function
    function generateLinuxScript(ffmpegCommandWithPlaceholders, params) {
        // Escape backticks and other special characters for JavaScript template literal
        const escapedFfmpegCommand = ffmpegCommandWithPlaceholders.replace(/`/g, '\\`');

        const script = `#!/bin/bash
# This script processes files provided as arguments.
# It re-encodes them using FFMPEG with the specified parameters,
# adding "_reencoded" to the original filename.

if [ "$#" -eq 0 ]; then
    echo "No files provided. Please drag and drop files onto the script (if your environment supports it for .sh files) or provide them as arguments in the terminal."
    echo "Usage: ./your_script_name.sh file1.mp4 file2.mkv ..."
    exit 1
fi

for file in "$@"; do
    echo "Processing file: \\"$file\\"" # Escaped quotes for JS

    # Get filename components
    FILENAME_WITH_EXT="\${file##*/}"                      # Get filename with extension (e.g., video.mp4)
    EXTENSION_PART="\${FILENAME_WITH_EXT##*.}"             # Get extension part (e.g., mp4)
    FILENAME_NO_EXT="\${FILENAME_WITH_EXT%.*}"            # Get filename without extension part (e.g., video)

    # Determine actual base name and extension for output construction
    OUTPUT_BASENAME=""
    OUTPUT_EXTENSION_WITH_DOT="" # Will include the dot if there's an extension

    if [[ "$FILENAME_WITH_EXT" == "$EXTENSION_PART" ]]; then # Filename has no dot (no extension) or is a dotfile like .config
        if [[ "$FILENAME_WITH_EXT" == .* ]]; then # It's a dotfile like .config (FILENAME_NO_EXT would be empty)
            OUTPUT_BASENAME="$FILENAME_WITH_EXT" # e.g. .config
        else # No extension like 'myfile'
            OUTPUT_BASENAME="$FILENAME_WITH_EXT" # e.g. myfile
        fi
    elif [[ "$FILENAME_NO_EXT" == "" ]]; then # Filename starts with a dot and has an extension (e.g., .config.old -> EXTENSION_PART=old, FILENAME_NO_EXT=.config)
         OUTPUT_BASENAME="$FILENAME_WITH_EXT" # Treat as if no extension for suffixing, e.g. .config.old_reencoded
    else # Common case: filename.extension
        OUTPUT_BASENAME="$FILENAME_NO_EXT"
        OUTPUT_EXTENSION_WITH_DOT=".$EXTENSION_PART"
    fi
    
    # Construct output filename
    OUTPUT_FILENAME="\${OUTPUT_BASENAME}_reencoded\${OUTPUT_EXTENSION_WITH_DOT}"
    
    # If input and output names are identical (e.g. processing a "_reencoded" file by mistake), skip or warn.
    if [[ "$file" == "$OUTPUT_FILENAME" ]]; then
        echo "Skipping file because input and output names would be identical: $file"
        continue
    fi

    echo "Output will be: \\"$OUTPUT_FILENAME\\"" # Escaped quotes for JS

    # Prepare the FFMPEG command for the current file.
    # The placeholders in ffmpegCommandWithPlaceholders are "$INPUT_FILE" and "$OUTPUT_FILE_REENCODED" (literally)
    
    # Safely prepare variables for sed replacement.
    # This handles spaces, newlines, and sed special characters in filenames.
    INPUT_FILE_SAFE_FOR_SED=$(printf '%s\\n' "$file" | sed 's:[\\/&]:\\\\&:g;$!s/$/\\\\n/') 
    INPUT_FILE_SAFE_FOR_SED="\${INPUT_FILE_SAFE_FOR_SED//$'\\n'/\\n}" 
    OUTPUT_FILENAME_SAFE_FOR_SED=$(printf '%s\\n' "$OUTPUT_FILENAME" | sed 's:[\\/&]:\\\\&:g;$!s/$/\\\\n/')
    OUTPUT_FILENAME_SAFE_FOR_SED="\${OUTPUT_FILENAME_SAFE_FOR_SED//$'\\n'/\\n}"

    # The command template itself might contain characters that sed interprets.
    # However, we are replacing fixed placeholder strings, so we only need to escape the placeholders for sed.
    FFMPEG_COMMAND_TEMPLATE="${escapedFfmpegCommand}"

    # Define placeholders as they appear in FFMPEG_COMMAND_TEMPLATE
    # These are literal strings "$INPUT_FILE" and "$OUTPUT_FILE_REENCODED"
    # We need to escape them for the sed 'find' pattern.
    # \$ for shell, then \\\$ for sed to see literal $
    # Quotes need to be matched: \\" for shell, then \\\\\\" for sed to see literal "
    PLACEHOLDER_IN_SED_FIND="\\\"\\\\\\$INPUT_FILE\\\\\\\""
    PLACEHOLDER_OUT_SED_FIND="\\\"\\\\\\$OUTPUT_FILE_REENCODED\\\\\\\""
    
    # Substitute placeholders with the prepared safe filenames
    # Using % as delimiter for sed to avoid issues if filenames contain /
    CURRENT_FFMPEG_COMMAND=$(echo "$FFMPEG_COMMAND_TEMPLATE" | sed "s%${PLACEHOLDER_IN_SED_FIND}%\\"$INPUT_FILE_SAFE_FOR_SED\\"%g" | sed "s%${PLACEHOLDER_OUT_SED_FIND}%\\"$OUTPUT_FILENAME_SAFE_FOR_SED\\"%g")

    echo "Running: $CURRENT_FFMPEG_COMMAND"
    eval "$CURRENT_FFMPEG_COMMAND" # Using eval to correctly process quotes and expansions

    echo ""
done

echo "All files processed."
`;
        return script;
    }

    function copyToClipboard(textareaId, buttonId) {
        const textarea = document.getElementById(textareaId);
        const button = document.getElementById(buttonId);
        const icon = 'üìÑ'; // Using page icon for copy

        // Determine original button text based on ID (could also store original text in a data attribute)
        let originalButtonText = "";
        if (buttonId === 'copyWindowsBtn') {
            originalButtonText = `${icon} Copy Windows Script`;
        } else if (buttonId === 'copyLinuxBtn') {
            originalButtonText = `${icon} Copy Linux Script`;
        }


        if (!textarea || !button) {
            console.error("Error: Textarea or button not found for copy operation.", textareaId, buttonId);
            alert('Error setting up copy functionality.');
            return;
        }

        if (!navigator.clipboard) {
            alert('Clipboard API not available in your browser. Please copy manually.');
            textarea.select();
            try {
                document.execCommand('copy');
                button.textContent = `${icon} Selected! (manual copy)`;
            } catch (e) {
                button.textContent = `${icon} Error selecting!`;
            }
            setTimeout(() => {
                button.textContent = originalButtonText;
            }, 3000);
            return;
        }

        navigator.clipboard.writeText(textarea.value)
            .then(() => {
                button.textContent = `${icon} Copied!`;
                button.disabled = true;
                setTimeout(() => {
                    button.textContent = originalButtonText;
                    button.disabled = false;
                }, 2000); 
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy text. See console for details. Please copy manually.');
                textarea.select();
                try {
                    document.execCommand('copy');
                    button.textContent = `${icon} Selected! (manual copy)`;
                } catch (e) {
                    button.textContent = `${icon} Error selecting!`;
                }
                setTimeout(() => {
                    button.textContent = originalButtonText;
                }, 3000);
            });
    }


    // Event Listener for "Generate Scripts" Button
    if (generateBtn) {
        generateBtn.addEventListener('click', handleGenerateScripts);
    } else {
        console.error("Error: Generate button not found. Check generateBtn ID.");
    }

    // Event Listeners for Copy Buttons
    if (copyWindowsBtn) {
        copyWindowsBtn.addEventListener('click', () => copyToClipboard('windowsScript', 'copyWindowsBtn'));
    } else {
        console.error("Error: Copy Windows button not found. Check copyWindowsBtn ID.");
    }

    if (copyLinuxBtn) {
        copyLinuxBtn.addEventListener('click', () => copyToClipboard('linuxScript', 'copyLinuxBtn'));
    } else {
        console.error("Error: Copy Linux button not found. Check copyLinuxBtn ID.");
    }

    // handleGenerateScripts Function
    function handleGenerateScripts() {
        // Retrieve values from input fields
        // const inputFileVal = inputFileEl.value.trim(); // Removed
        // const outputFileVal = outputFileEl.value.trim(); // Removed
        const resolutionVal = resolutionEl.value.trim();
        const videoCodecVal = videoCodecEl.value.trim();
        const audioCodecVal = audioCodecEl.value.trim();
        const bitrateVal = videoBitrateEl.value.trim();

        // Basic Validation - Removed for inputFileVal and outputFileVal

        // Store gathered values in an object
        const params = {
            // inputFile: inputFileVal, // Removed
            // outputFile: outputFileVal, // Removed
            resolution: resolutionVal,
            videoCodec: videoCodecVal, // This could be empty if user clears it
            audioCodec: audioCodecVal, // This could be empty if user clears it
            bitrate: bitrateVal
        };

        // Log collected parameters
        console.log("Collected Parameters:", params);

        // Generate FFMPEG command
        const ffmpegCommand = generateFfmpegCommand(params);
        console.log("Generated FFMPEG Command:", ffmpegCommand);

        // Generate Windows Batch Script
        const windowsBatchScript = generateWindowsScript(ffmpegCommand, params);
        
        // Generate Linux Shell Script
        const linuxShellScript = generateLinuxScript(ffmpegCommand, params);

        // Update textareas
        if (windowsScriptArea && linuxScriptArea) {
            windowsScriptArea.value = windowsBatchScript;
            linuxScriptArea.value = linuxShellScript;
        } else {
            console.error("Error: Script output textareas not found. Check element IDs.");
        }
    }
});
    </script>
</body>
</html>
